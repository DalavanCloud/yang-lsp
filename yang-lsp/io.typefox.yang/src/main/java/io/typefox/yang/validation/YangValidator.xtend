/*
 * generated by Xtext 2.13.0-SNAPSHOT
 */
package io.typefox.yang.validation

import com.google.common.collect.HashMultimap
import com.google.inject.Inject
import com.google.inject.Singleton
import io.typefox.yang.types.YangEnumeration
import io.typefox.yang.utils.YangExtensions
import io.typefox.yang.utils.YangNameUtils
import io.typefox.yang.utils.YangTypeExtensions
import io.typefox.yang.yang.Bit
import io.typefox.yang.yang.Enum
import io.typefox.yang.yang.FractionDigits
import io.typefox.yang.yang.Modifier
import io.typefox.yang.yang.Pattern
import io.typefox.yang.yang.Position
import io.typefox.yang.yang.Refinable
import io.typefox.yang.yang.Statement
import io.typefox.yang.yang.Type
import io.typefox.yang.yang.YangVersion
import org.eclipse.emf.ecore.xml.type.internal.RegEx.ParseException
import org.eclipse.emf.ecore.xml.type.internal.RegEx.RegularExpression
import org.eclipse.xtext.validation.Check

import static io.typefox.yang.utils.YangExtensions.*
import static io.typefox.yang.validation.IssueCodes.*
import static io.typefox.yang.yang.YangPackage.Literals.*

import static extension com.google.common.base.Strings.nullToEmpty

/**
 * This class contains custom validation rules for the YANG language. 
 */
@Singleton
class YangValidator extends AbstractYangValidator {

	@Inject
	extension YangExtensions;

	@Inject
	extension YangTypeExtensions;

	@Inject
	SubstatementRuleProvider substatementRuleProvider;

	@Inject
	SubstatementFeatureMapper featureMapper;

	@Check
	def void checkVersion(YangVersion it) {
		if (yangVersion != YANG_1 && yangVersion != YANG_1_1) {
			val message = '''The version must be either '«YANG_1»' or '«YANG_1_1»'.''';
			error(message, it, YANG_VERSION__YANG_VERSION, INCORRECT_VERSION);
		}
	}

	@Check
	def void checkSubstatements(Statement it) {
		substatementRuleProvider.get(eClass)?.checkSubstatements(it, this, featureMapper);
	}

	@Check
	def void checkTypeRestriction(Type it) {
		// https://tools.ietf.org/html/rfc7950#section-9.2.3
		// https://tools.ietf.org/html/rfc7950#section-9.3.3
		// Same for string it just has another statement name.
		// https://tools.ietf.org/html/rfc7950#section-9.4.3
		val refinements = substatementsOfType(Refinable);
		if (!refinements.nullOrEmpty) {
			val expectedRefinementKind = refinementKind;
			refinements.forEach [
				if (expectedRefinementKind === null || !(expectedRefinementKind.isAssignableFrom(it.class))) {
					val message = '''Type cannot have '«YangNameUtils.getYangName(it.eClass)»' restriction statement.''';
					error(message, it, REFINABLE__EXPRESSION, TYPE_ERROR);
				}
			];
		}
	}

	@Check
	def checkRefinement(Refinable it) {
		val yangRefinable = yangRefinable;
		if (yangRefinable !== null) {
			yangRefinable.validate(this);
		}
	}

	@Check
	def checkUnionType(Type it) {
		if (unionBuiltin) {
			// At least one `type` sub-statement should be present for each `union` type.
			// https://tools.ietf.org/html/rfc7950#section-9.12
			if (substatementsOfType(Type).nullOrEmpty) {
				val message = '''Type substatement must be present for each union type.''';
				error(message, it, TYPE__TYPE_REF, TYPE_ERROR);
			}
		}
	}

	@Check
	def checkBitsType(Type it) {
		if (subtypeOfBits) {
			// The "bit" statement, which is a sub-statement to the "type" statement, must be present if the type is "bits".
			// https://tools.ietf.org/html/rfc7950#section-9.7.4
			val bits = substatementsOfType(Bit);
			if (bits.nullOrEmpty && builtin) {
				val message = '''Bits type must have at least one "bit" statement.''';
				error(message, it, TYPE__TYPE_REF, TYPE_ERROR);
			} else {
				// All assigned names in a bits type must be unique.
				// https://tools.ietf.org/html/rfc7950#section-9.7.4
				val nameNodeMapping = HashMultimap.create;
				bits.forEach[nameNodeMapping.put(name, it)];
				nameNodeMapping.asMap.forEach [ name, statementsWithSameName |
					if (statementsWithSameName.size > 1) {
						statementsWithSameName.forEach [
							val message = '''All assigned names in a bits type must be unique.''';
							error(message, it, BIT__NAME, TYPE_ERROR);
						];
					}
				];
				// All assigned positions in a bits type must be unique
				// https://tools.ietf.org/html/rfc7950#section-9.7.4.2
				val positionNodeMapping = HashMultimap.create;
				val allPositions = bits.map[firstSubstatementsOfType(Position)];
				val assignedPositions = allPositions.filterNull;
				assignedPositions.forEach[positionNodeMapping.put(position, it)];
				positionNodeMapping.asMap.forEach [ position, statementsWithSamePosition |
					if (statementsWithSamePosition.size > 1) {
						statementsWithSamePosition.forEach [
							val message = '''All assigned positions in a bits type must be unique.''';
							error(message, it, POSITION__POSITION, TYPE_ERROR);
						];
					}
				];

				val maxPosition = newArrayList(0L);
				// Assigned values must be between 0 and 4294967295.
				// https://tools.ietf.org/html/rfc7950#section-9.7.4.2
				bits.forEach [
					val position = firstSubstatementsOfType(Position);
					val positionValue = position?.position;
					if (positionValue !== null) {
						try {
							val value = Long.parseLong(positionValue);
							if (value < 0L || value > 4294967295L) {
								throw new NumberFormatException;
							}
							if (value > maxPosition.head.longValue) {
								maxPosition.set(0, value);
							}
						} catch (NumberFormatException e) {
							val message = 'Assigned positions must be an unsigned integer between 0 and 4294967295.';
							error(message, position, POSITION__POSITION, TYPE_ERROR);
						}
					} else {
						// If the current highest bit position value is equal to 4294967295,
						// then a position value must be specified for "bit" sub-statements
						// following the one with the current highest position value.
						if (maxPosition.head.longValue >= 4294967295L) {
							val message = '''Cannot automatically asign a value to position. An explicit position has to be assigned instead.''';
							error(message, it, BIT__NAME, TYPE_ERROR);
						} else {
							maxPosition.set(0, maxPosition.head.longValue + 1);
						}
					}
				];

				// When an existing bits type is restricted, the "position" statement
				// must either have the same value as in the base type or not be
				// present, in which case the value is the same as in the base type.
				// No need to validate the direct subtype of bits as no restrictions are applied on them.
				if (!bitsBuiltin) {
					val currentType = it;
					val allBitNames = HashMultimap.<String, Bit>create;
					typeHierarchy.filter[it !== currentType].forEach [
						substatementsOfType(Bit).forEach [
							allBitNames.put(name, it);
						];
					];

					bits.forEach [
						val message = '''A new assigned name must not declared when restricting an existing bits type.''';
						val bitWithSameNames = allBitNames.get(name);
						if (bitWithSameNames.nullOrEmpty) {
							error(message, it, BIT__NAME, TYPE_ERROR);
						} else {
							val position = firstSubstatementsOfType(Position);
							val positionValue = position?.position;
							val parentPositions = bitWithSameNames.map[firstSubstatementsOfType(Position)].filterNull.
								map[it.position];
							if (positionValue !== null && !parentPositions.exists[positionValue == it]) {
								error(message, position, POSITION__POSITION, TYPE_ERROR);
							}
						}
					];
				}
			}
		}
	}

	@Check
	def checkEnumeration(Type type) {
		if (type.subtypeOfEnumeration) {
			val yangEnumeration = type.yangEnumeration;
			if (yangEnumeration !== null && yangEnumeration !== YangEnumeration.NOOP) {
				yangEnumeration.validate(this);
			}
		} else {
			type.substatementsOfType(Enum).forEach [
				val message = '''Only enumeration types can have a "enum" statement.''';
				error(message, type, TYPE__TYPE_REF, TYPE_ERROR);
			];
		}
	}

	@Check
	def checkFractionDigitsExist(Type it) {
		// https://tools.ietf.org/html/rfc7950#section-9.3.4
		val fractionDigits = firstSubstatementsOfType(FractionDigits);
		val fractionDigitsExist = fractionDigits !== null;
		// Note, only the decimal type definition MUST have the `fraction-digits` statement.
		// It is not mandatory for types that are derived from decimal built-ins. 
		val decimalBuiltin = decimalBuiltin;
		if (decimalBuiltin) {
			if (fractionDigitsExist) {
				// Validate the fraction digits. It takes as an argument an integer between 1 and 18, inclusively.
				val value = fractionDigitsAsInt;
				if (value.intValue < 1 || value.intValue > 18) {
					val message = '''The "fraction-digits" value must be an integer between 1 and 18, inclusively.''';
					error(message, fractionDigits, FRACTION_DIGITS__RANGE, TYPE_ERROR);
				}

			} else {
				// Decimal types must have fraction-digits sub-statement.
				val message = '''The "fraction-digits" statement must be present for "decimal64" types.''';
				error(message, it, TYPE__TYPE_REF, TYPE_ERROR);
			}
		} else {
			if (fractionDigitsExist) {
				val message = '''Only decimal64 types can have a "fraction-digits" statement.''';
				error(message, it, TYPE__TYPE_REF, TYPE_ERROR);
			}
		}
	}

	@Check
	def checkPattern(Pattern it) {
		// https://tools.ietf.org/html/rfc7950#section-9.4.5
		if (eContainer instanceof Type) {
			val type = eContainer as Type;
			if (type.subtypeOfString) {
				try {
					new RegularExpression(regexp.nullToEmpty, 'X');
				} catch (ParseException e) {
					val message = if (regexp.nullOrEmpty) {
							'Regular expression must be specified.'
						} else {
							'''Invalid regular expression pattern: "«regexp»".''';
						}
					error(message, it, PATTERN__REGEXP, TYPE_ERROR);
				}
			} else {
				val message = '''Only string types can have a "pattern" statement.''';
				error(message, type, TYPE__TYPE_REF, TYPE_ERROR);
			}
		}
	}

	@Check
	def checkModifier(Modifier it) {
		// https://tools.ietf.org/html/rfc7950#section-9.4.6
		if (modifier != 'invert-match') {
			val message = '''Modifier value must be "invert-match".''';
			error(message, it, MODIFIER__MODIFIER, TYPE_ERROR);
		}
	}

}
