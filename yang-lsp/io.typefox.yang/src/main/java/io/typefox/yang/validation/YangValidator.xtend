/*
 * generated by Xtext 2.13.0-SNAPSHOT
 */
package io.typefox.yang.validation

import com.google.inject.Inject
import com.google.inject.Singleton
import io.typefox.yang.utils.YangTypeExtensions
import io.typefox.yang.yang.BinaryOperation
import io.typefox.yang.yang.Range
import io.typefox.yang.yang.Statement
import io.typefox.yang.yang.Type
import io.typefox.yang.yang.YangVersion
import org.eclipse.xtext.validation.Check

import static io.typefox.yang.utils.YangExtensions.*
import static io.typefox.yang.validation.IssueCodes.*
import static io.typefox.yang.yang.YangPackage.Literals.*

import static extension org.eclipse.xtext.EcoreUtil2.getAllContentsOfType

/**
 * This class contains custom validation rules for the YANG language. 
 */
@Singleton
class YangValidator extends AbstractYangValidator {
	
	static val RANGE_BINARY_OPERATORS = #{'|', '..'};

	@Inject
	extension YangTypeExtensions;

	@Inject
	SubstatementRuleProvider substatementRuleProvider;

	@Inject
	SubstatementFeatureMapper featureMapper;

	@Check
	def void checkVersion(YangVersion it) {
		if (yangVersion != YANG_1 && yangVersion != YANG_1_1) {
			val message = '''The version must be either '«YANG_1»' or '«YANG_1_1»'.''';
			error(message, it, YANG_VERSION__YANG_VERSION, INCORRECT_VERSION);
		}
	}

	@Check
	def void checkSubstatements(Statement it) {
		substatementRuleProvider.get(eClass)?.checkSubstatements(it, this, featureMapper);
	}

	@Check
	def void checkTypeRestriction(Type it) {
		// https://tools.ietf.org/html/rfc7950#section-9.2.3
		// https://tools.ietf.org/html/rfc7950#section-9.3.3
		if (!subTypeOfNumber) {
			getAllContentsOfType(Range).forEach [
				val message = '''Only integer and decimal types can be restricted with the 'range' statement.''';
				error(message, it, RANGE__EXPRESSION, SYNTAX_ERROR);
			];
		}
	}

	@Check
	def checkRange(Range it) {
		if (checkSyntax) {
			val yangRange = yangRange;
			if (yangRange !== null) {
				yangRange.validate(this);
			}
		}
		checkSyntax && yangRange.validate(this);
	}

	private def boolean checkSyntax(Range it) {
		val invalidOperations = getAllContentsOfType(BinaryOperation).filter[!RANGE_BINARY_OPERATORS.contains(operator)];
		invalidOperations.forEach [
			val message = '''Syntax error. Unexpected operator "«operator»".''';
			error(message, it, BINARY_OPERATION__OPERATOR, SYNTAX_ERROR);
		];
		return invalidOperations.nullOrEmpty;
	}

}
