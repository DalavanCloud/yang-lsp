/*
 * generated by Xtext 2.13.0-SNAPSHOT
 */
package io.typefox.yang.validation

import com.google.common.collect.Iterables
import com.google.inject.Inject
import com.google.inject.Singleton
import io.typefox.yang.yang.Import
import io.typefox.yang.yang.Module
import io.typefox.yang.yang.Revision
import io.typefox.yang.yang.Statement
import io.typefox.yang.yang.YangVersion
import java.util.Collection
import java.util.Collections
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.validation.Check

import static com.google.common.base.CaseFormat.*
import static io.typefox.yang.validation.YangIssueCodes.*
import static io.typefox.yang.yang.YangPackage.Literals.*

/**
 * This class contains custom validation rules for the YANG language. 
 */
@Singleton
class YangValidator extends AbstractYangValidator {

	@Inject
	YangCardinalitiesHelper cardinalitiesHelper;

	@Check
	def void checkVersion(YangVersion it) {
		if (yangVersion != "1.1") {
			error("The version must be '1.1'.", it, YANG_VERSION__YANG_VERSION, INCORRECT_VERSION);
		}
	}

	@Check
	def void checkModuleCardinalities(Module module) {
		checkCardinalities(module, MODULE_SUB_STATEMENT_CARDINALITY, [module -> MODULE__NAME]);
	}

	@Check
	def void checkImportCardinalities(Import _import) {
		checkCardinalities(_import, IMPORT_SUB_STATEMENT_CARDINALITY, [_import -> IMPORT__MODULE]);
	}
	
	@Check
	def void checkImportCardinalities(Revision revision) {
		checkCardinalities(revision, REVISION_SUB_STATEMENT_CARDINALITY, [revision -> REVISION__REVISION]);
	}

	private def <S extends Statement> checkCardinalities(S container, String issueCode,
		(S)=>Pair<? extends EObject, ? extends EStructuralFeature> issueLocationProvider) {

		val allStatements = container.subStatements;
		val Collection<Statement> invalidStatements = newArrayList(allStatements);
		cardinalitiesHelper.getCardinalitiesFor(container.eClass).entrySet.forEach [
			val clazz = key.instanceClass;
			val statements = allStatements.filter(clazz);
			invalidStatements.removeAll(statements);
			val actualCardinality = statements.size;
			val expectedCardinality = value;
			if (!expectedCardinality.contains(actualCardinality)) {
				val containerName = container.eClass.instanceClass.simpleName.toLowerCase;
				val message = '''Expected '«clazz.yangName»' with «expectedCardinality» cardinality for «containerName». Got «actualCardinality» instead.''';
				if (actualCardinality === 0) {
					val issueLocation = issueLocationProvider.apply(container);
					error(message, issueLocation.key, issueLocation.value, issueCode);
				} else {
					statements.forEach [
						val index = allStatements.indexOf(it);
						error(message, container, STATEMENT__SUB_STATEMENTS, index, issueCode);
					];
				}
			}
		];
		invalidStatements.forEach[
			val index = allStatements.indexOf(it);
			error('''Unexpected declaration of '«eClass.yangName»' statement.''', container, STATEMENT__SUB_STATEMENTS, index, INVALID_SUB_STATEMENT);
		]
	}
	
	private def dispatch String getYangName(EClass it) {
		return instanceClass.yangName;
	}
	
	private def dispatch String getYangName(Class<?> it) {
		return UPPER_CAMEL.converterTo(LOWER_HYPHEN).convert(simpleName);
	}
	
	private def removeAll(Iterable<?> removeFrom, Iterable<?> removeThese) {
		removeThese.forEach[
			Iterables.removeAll(removeFrom, Collections.singleton(it));
		];
	}

}
